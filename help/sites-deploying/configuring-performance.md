---
title: パフォーマンスの最適化
description: パフォーマンスを最適化するために AEM の特定の側面を設定する方法を説明します。
contentOwner: User
products: SG_EXPERIENCEMANAGER/6.5/SITES
content-type: reference
topic-tags: configuring
feature: Configuring
solution: Experience Manager, Experience Manager Sites
role: Admin
exl-id: c46d9569-23e7-44e2-a072-034450f14ca2
source-git-commit: a869ffbc6015fd230285838d260434d9c0ffbcb0
workflow-type: tm+mt
source-wordcount: '5052'
ht-degree: 99%

---

# パフォーマンスの最適化 {#performance-optimization}

>[!NOTE]
>
>パフォーマンスに関する問題のトラブルシューティングと修正について詳しくは、[パフォーマンスツリー](/help/sites-deploying/performance-tree.md)も参照してください。
>
>さらに、[パフォーマンスチューニングのヒント](https://experienceleague.adobe.com/ja/docs/experience-cloud-kcs/kbarticles/ka-17466)に関するナレッジベース記事を参照することもできます。

Web サイトが訪問者の要求に応答するまでにどの程度の時間がかかるかは、非常に重要な問題です。応答時間は個々の要求によって異なりますが、平均的なターゲット時間の値を定義することはできます。この値が達成可能で維持可能であることが判明したら、それを使用して、web サイトのパフォーマンスを監視し、潜在的な問題が発生しつつあるときにそれを示すことができます。

ターゲットオーディエンスの特性が異なることを反映して、オーサー環境とパブリッシュ環境では、目標とする応答時間が異なります。

## オーサー環境 {#author-environment}

この環境は、作成者がコンテンツを入力および更新する際に使用します。コンテンツページとそれらのページ上の個々の要素を更新する際に、パフォーマンスを集中的に消費する多数のリクエストを発生させる少数のユーザーに対応する必要があります。

## パブリッシュ環境 {#publish-environment}

この環境には、ユーザーに公開するコンテンツが置かれます。ここでは、リクエストの数がさらに多くなり、速度が極めて重要になります。しかし、リクエストの性質はそれほど動的ではないので、コンテンツのキャッシュやロードバランシングなどの付加的なパフォーマンス強化メカニズムを適用できます。

>[!NOTE]
>
>* パフォーマンス最適化のための設定が完了したら、[Tough Day](/help/sites-developing/tough-day.md) の手順に従って、高負荷の環境をテストしてください。
>* [パフォーマンスチューニングのヒント](https://experienceleague.adobe.com/ja/docs/experience-cloud-kcs/kbarticles/ka-17466)も参照してください。

## パフォーマンスの最適化方法 {#performance-optimization-methodology}

AEM プロジェクトのパフォーマンスを最適化する方法は、5 つの非常に単純なルールに要約されます。それらのルールを守れば、パフォーマンスの問題を未然に防ぐことができます。

1. [最適化の計画](#planning-for-optimization)
1. [実際の状況に近いシミュレーション](#simulate-reality)
1. [適切な目標設定](#establish-solid-goals)
1. [妥当性の維持](#stay-relevant)
1. [アジャイルな反復サイクル](#agile-iteration-cycles)

これらのルールは web プロジェクト全般に当てはまり、プロジェクトマネージャーやシステム管理者にとっては、プロジェクトの立ち上げ時にパフォーマンスの問題に悩まされないようにするために有効です。

### 最適化の計画 {#planning-for-optimization}

![chlimage_1-3](assets/chlimage_1-3.jpeg)

パフォーマンス最適化フェーズには、プロジェクト全体の作業のうち約 10％を予定します。実際のパフォーマンス最適化要件は、プロジェクトの複雑さのレベルと開発チームの経験によって異なります。プロジェクトによっては、そこまで時間を割く必要がなかったという結果になる可能性もありますが、パフォーマンス最適化には必ずこの程度の手間を見込んで計画を立てるのが実用的です。

プロジェクトの稼動開始当初は、可能な限り、少ないユーザーを対象として緩やかに運用を開始するのが望ましいと考えられます。そうすれば、全面的なサービス公開による過大なプレッシャーにさらされることなく、本番の経験を蓄積して最適化をいっそう進めることができるからです。

「本番」に入っても、パフォーマンスの最適化は終わりません。現在は、システムに「実際」の負荷が発生しています。開始後に追加の調整を計画することが重要です。

システムの負荷が変わり、システムのパフォーマンスプロファイルが時間の経過と共に変化するので、パフォーマンスの「調整」または「ヘルスチェック」は 6 か月～12 か月間隔でスケジュールする必要があります。

### 実際の状況に近いシミュレーション {#simulate-reality}

![chlimage_1-4](assets/chlimage_1-4.jpeg)

Web サイトの運用を開始した後で、パフォーマンスの問題が判明した場合、負荷とパフォーマンスのテストで実際の状況に十分近いシミュレーションができていなかった可能性が高いです。

実際の状況に近いシミュレーションを行うことは難しく、「実際」の追求にどこまで手間をかけるかは、プロジェクトの性質によって判断します。「実際」とは、「実際のコード」や「実際のトラフィック」に限りません。「実際のコンテンツ」、特にコンテンツのサイズや構造が実際的であることも重要です。テンプレートの動作は、リポジトリのサイズと構造によって異なる場合があります。

### 適切な目標設定 {#establish-solid-goals}

![chlimage_1-5](assets/chlimage_1-5.jpeg)

適切なパフォーマンス目標を設定することの重要性を軽視してはいけません。多くの場合、何らかのパフォーマンス目標に基づく活動を一旦開始すると、たとえその目標に確かな根拠がないとしても、後で軌道修正することは非常に困難です。

どうすれば適切で確実性の高いパフォーマンス目標を設定できるかというのは非常に難しい問題です。多くの場合、最も参考になるのは、類似性がある web サイト（例えば、新しい web サイトの前身となった web サイト）から実際のログとベンチマークを収集することです。

### 妥当性の維持 {#stay-relevant}

![chlimage_1-6](assets/chlimage_1-6.jpeg)

ボトルネックの最適化は 1 つずつ適用していくことが重要です。ある対策の影響を検証しないうちに別の作業も並行して行うと、どの最適化対策が実際に効果を発揮したのかわからなくなります。

### アジャイルな反復サイクル {#agile-iteration-cycles}

![chlimage_1-7](assets/chlimage_1-7.jpeg)

パフォーマンスのチューニングは、目標を達成するまで測定、分析、最適化および検証のサイクルを続ける反復的なプロセスです。この点を考慮すると、サイクルを 1 周するごとに後で大がかりなテストプロセスを実施するよりも、最適化フェーズ内でアジャイルな検証プロセスを実施するほうがよいと考えられます。

これはつまり最適化作業を実施する開発者には、最適化目標が達成された場合にその事実をすぐ把握できる手段が必要だということです。目標に到達すれば最適化は終了するため、この情報は大きな価値があります。

## 基本的なパフォーマンスのガイドライン {#basic-performance-guidelines}

一般的に、キャッシュされていない HTML 要求の応答時間は 100 ミリ秒未満に抑えます。より具体的には、次のようなガイドラインに従います。

* ページリクエストの 70％は、100 ミリ秒未満で応答する。
* ページリクエスト件数の 25％に対して 100 ミリ秒～300 ミリ秒の範囲で応答する。
* ページリクエスト件数の 4％に対して 300 ミリ秒～500 ミリ秒の範囲で応答する。
* ページリクエスト件数の 1％に対して 500 ミリ秒～1000 ミリ秒の範囲で応答する。
* どのページについても、応答時間が 1 秒を超えてはいけません。

以上の数値は、次の条件を前提としています。

* パブリッシュ環境で測定（オーサー環境に関連するオーバーヘッドがない）
* サーバー上で測定される（ネットワークオーバーヘッドを考慮しない）
* キャッシュなし（ AEM Output キャッシュや Dispatcher キャッシュを考慮しない）
* 多数の依存ファイル（HTML、JS、PDF など）を伴う複雑な要求のみ
* 他のシステム負荷なし

パフォーマンスの問題に頻繁に影響を与える次のような問題がいくつかあります。

* Dispatcher キャッシュの非効率性
* 通常の表示テンプレート内で使用されるクエリ

JVM および OS レベルの調整は、通常、大幅なパフォーマンス向上には結び付かないので、最適化サイクルの最後に実行すれば十分です。

コンテンツリポジトリの構造化の方法はパフォーマンスにも影響を及ぼす可能性があります。最適なパフォーマンスを確保するために、コンテンツリポジトリ内の個々のノードに接続される子ノードの数は、ルールとして 1,000 個未満にする必要があります。

通常のパフォーマンス最適化では、次の要素を使用します。

* `request.log`
* コンポーネントベースのタイミング
* Java™プロファイラー。

### デジタルアセットの読み込みと編集時のパフォーマンス {#performance-when-loading-and-editing-digital-assets}

デジタルアセットの読み込みと編集には大量のデータが関与するので、パフォーマンスが問題になる場合があります。

この場合、次の 2 つの要素がパフォーマンスに影響します。

* CPU - 複数のコアがあると、トランスコーディングの際に処理がスムーズに行われます。
* ハードディスク - 並列の RAID ディスクを使用しても、同じ効果を得ることができます。

パフォーマンスを向上させるには、次の点を考慮します。

* 1 日にアップロードするアセットの数。次の式を基に概算できます。

![chlimage_1-77](assets/chlimage_1-77.png)

* 編集を行う時間枠（通常は営業日の長さで、国際業務の場合はより長い時間が必要になります）。
* アップロードする画像の MB 単位の平均サイズ（および 1 つの画像につき生成されるレンディションのサイズ）。
* 平均データレートは次の式で算出されます。

![chlimage_1-78](assets/chlimage_1-78.png)

* すべての編集の 80％が 20％の時間内に行われるため、ピーク時には平均のデータレートの 4 倍になります。このようなパフォーマンスを目標にします。

## パフォーマンスの監視 {#performance-monitoring}

パフォーマンス（またはパフォーマンスの不足）は、ユーザーが最初に認識する事柄の 1 つであるため、ユーザーインターフェイスを備えた他のアプリケーションと同様に、パフォーマンスは非常に重要です。AEM インストールのパフォーマンスを最適化するには、インスタンスの様々な属性とインスタンスの動作を監視する必要があります。

パフォーマンスの監視を実行する方法について詳しくは、[パフォーマンスの監視](/help/sites-deploying/monitoring-and-maintaining.md#monitoring-performance)を参照してください。

多くの場合、パフォーマンスの問題を引き起こす原因をトラックするのは、その影響が明白に確認できる状態であったとしても困難です。

まずは、正常に稼動しているシステムについて熟知しておく必要があります。適切に稼動する環境がどのように「見え」、「動作する」のかを把握していないと、パフォーマンスが低下したときに問題を特定するのが難しくなります。十分な時間をかけてスムーズに稼働しているシステムを調査し、パフォーマンス情報の収集が継続的なタスクであることを理解しておく必要があります。これにより、パフォーマンスが低下した場合に比較するための基準を設けることができます。

次の図は、AEM コンテンツの要求のパスおよびパフォーマンスに影響を及ぼす可能性のある様々な要素を示しています。

![chlimage_1-79](assets/chlimage_1-79.png)

パフォーマンスは、ボリュームと処理能力のバランスでもあります。

* **ボリューム** - システムが処理および提供する出力の量です。
* **処理能力** - システムがボリュームを提供する能力です。

パフォーマンスは、web チェーン全体の様々な場所で示されます。

![chlimage_1-80](assets/chlimage_1-80.png)

多くの場合、パフォーマンスに影響を与える機能領域がいくつかあります。

* キャッシュ
* アプリケーション（プロジェクト）コード
* 検索機能

### パフォーマンスに関する基本ルール {#basic-rules-regarding-performance}

パフォーマンスを最適化する際は、次の特定のルールに留意してください。

* パフォーマンスのチューニングを各プロジェクトでおこなう&#x200B;*。*
* 開発サイクルの初期段階で最適化を行わない。
* パフォーマンスの良さは最も弱いリンクによって決まる。
* 常に処理能力とボリュームを比較して考える。
* 最初に重要な要素から最適化する。
* 必ず現実的な目標を設定してから最適化を実施する&#x200B;*。*

>[!NOTE]
>
>パフォーマンスの測定に使用するメカニズムは、多くの場合、測定の対象に間違いなく影響を与えることに留意してください。この矛盾点を考慮して、与えられる影響を最小限に抑えるように努めてください。具体的には、ブラウザーのプラグインを可能な限り無効にするなどの手段があります。

## パフォーマンスの設定 {#configuring-for-performance}

パフォーマンスを最適化するために AEM（および基盤となるリポジトリ）の特定の要素を設定できます。設定可能な要素と推奨事項を次に示します。変更を行う前に、記載されている機能を使用するかどうか、またはどのように使用するかを確認しておく必要があります。

### 検索インデックスの作成 {#search-indexing}

AEM 6.0 以降、Adobe Experience Manager は Oak ベースのリポジトリアーキテクチャを使用してします。

更新されたインデックス作成の情報については、次のページを参照してください。

* [クエリとインデックスに関するベストプラクティス](/help/sites-deploying/best-practices-for-queries-and-indexing.md)
* [クエリとインデックス作成](/help/sites-deploying/queries-and-indexing.md)

### ワークフローの同時処理 {#concurrent-workflow-processing}

パフォーマンスを向上させるには、同時に実行するワークフロープロセス数を制限します。デフォルトでは、ワークフローエンジンで並行して処理できるワークフロー数は、Java™ VM で使用可能なプロセッサー数と同じになります。ワークフローのステップで大量の処理リソース（RAM または CPU）が必要な場合は、それらのワークフローの一部を並行して実行する際に、使用可能なサーバーリソースに大きな負担をかけることになります。

例えば、画像（または一般的な DAM アセット）をアップロードすると、ワークフローによって画像が DAM に自動的に読み込まれます。多くの場合、画像は高解像度で、その処理には数百 MB ものヒープが容易に消費されます。このような画像を並行して処理すると、メモリのサブシステムとガベージコレクターに大きな負荷がかかります。

ワークフローエンジンでは、Apache Sling のジョブキューを使用して、作業項目の処理の対応およびスケジュール設定を行います。デフォルトでは、ワークフロージョブの処理用に、Apache Sling Job Queue Configuration サービスファクトリから次のジョブキューサービスが作成されています。

<!-- TODO: Change the reference to 6.5 LTS javadocs -->
* Granite Workflow Queue：ワークフローのほとんどのステップ（DAM アセットを処理するステップなど）では、Granite Granite Workflow Queue サービスを使用します。
* Granite Workflow External Process Job Queue：このサービスは、通常は外部システムへのアクセスや結果のポーリングに使用される、特殊な外部ワークフローのステップに使用します。例えば、InDesign のメディア抽出プロセスステップは外部プロセスとして実装されます。ワークフローエンジンでは、ポーリングの処理に外部キューを使用します。（[com.day.cq.workflow.exec.WorkflowExternalProcess](https://developer.adobe.com/experience-manager/reference-materials/6-5-lts/javadoc/com/day/cq/workflow/exec/WorkflowExternalProcess.html) を参照してください）。

これらのサービスを設定して、同時に実行するワークフロープロセスの最大数を制限します。

>[!NOTE]
>
>特定のワークフローモデル用のジョブキューを作成していない限り、このようなジョブキューの設定はすべてのワークフローに影響を及ぼします（[特定のワークフロー用のキューの設定](/help/sites-deploying/configuring-performance.md#configure-the-queue-for-a-specific-workflow)を参照）。

#### リポジトリでの設定 {#configuration-in-the-repo}

[sling:OsgiConfig ノードを使用](/help/sites-deploying/configuring-osgi.md#adding-a-new-configuration-to-the-repository)してサービスを設定する場合は、既存のサービスの PID を探す必要があります。例：org.apache.sling.event.jobs.QueueConfiguration.370aad73-d01b-4a0b-abe4-20198d85f705Web コンソールを使用すると、PID を検出できます。

`queue.maxparallel` という名前のプロパティを設定します。

#### Web コンソールでの設定 {#configuration-in-the-web-console}

[Web コンソールを使用](/help/sites-deploying/configuring-osgi.md#osgi-configuration-with-the-web-console)してこれらのサービスを設定するには、Apache Sling Job Queue Configuration サービスファクトリで既存の設定項目を特定します。

Maximum Parallel Jobs という名前のプロパティを設定します。

### 特定のワークフロー用のキューの設定 {#configure-the-queue-for-a-specific-workflow}

特定のワークフローモデルのジョブキューを作成して、そのワークフローモデルのジョブ処理を設定できるようにします。この方法では、設定が特定のワークフロー用の処理に影響を及ぼします。一方、デフォルトの Granite Workflow Queue の設定はその他のワークフローの処理を制御します。

ワークフローモデルの実行時に、特定のトピックの Sling ジョブが作成されます。デフォルトでは、トピックは、一般的な Granite Workflow Queue または Granite Workflow External Process Job Queue 用に設定されるトピックに一致します。

* `com/adobe/granite/workflow/job*`
* `com/adobe/granite/workflow/external/job*`

ワークフローモデルが生成する実際のジョブトピックには、モデル固有のサフィックスが含まれます。例えば、**DAM アセットの更新**&#x200B;ワークフローモデルでは、次のトピックを含むジョブが生成されます。

`com/adobe/granite/workflow/job/etc/workflow/models/dam/update_asset/jcr_content/model`

そのため、ワークフローモデルのジョブトピックに一致するトピック用のジョブキューを作成できます。キューのパフォーマンス関連のプロパティの設定は、キュートピックに一致するジョブを生成するワークフローモデルにのみ影響を及ぼします。

次の手順では、例として **DAM アセットの更新**&#x200B;ワークフローを使用して、ワークフロー用のジョブキューを作成します。

1. ジョブキューを作成する対象となるワークフローモデルを実行します。これにより、トピックの統計が生成されます。例えば、アセットに画像を追加して、**DAM アセットの更新**&#x200B;ワークフローを実行します。
1. Sling ジョブコンソール（`https://<host>:<port>/system/console/slingevent`）をクリックします。
1. コンソールでワークフロー関連のトピックを確認します。DAM アセットの更新では、次のトピックが見つかります。

   * `com/adobe/granite/workflow/external/job/etc/workflow/models/dam/update_asset/jcr_content/model`
   * `com/adobe/granite/workflow/job/etc/workflow/models/dam/update_asset/jcr_content/model`
   * `com/adobe/granite/workflow/job/etc/workflow/models/dam-xmp-writeback/jcr_content/model`

1. これらのトピックごとに 1 つのジョブキューを作成します。ジョブキューを作成するには、Apache Sling Job Queue ファクトリサービス用のファクトリ設定を作成します。

   このファクトリ設定は、Topics プロパティがワークフロージョブのトピックに一致する点を除き、[ワークフローの同時処理](/help/sites-deploying/configuring-performance.md#concurrent-workflow-processing)で説明した Granite Workflow Queue と同様です。

### AEM DAM アセット同期サービス {#cq-dam-asset-synchronization-service}

`AssetSynchronizationService` は、マウントされたリポジトリ（LiveLink、Documentum® など）からのアセットの同期に使用します。デフォルトでは、300 秒（5 分）ごとに定期チェックが行われるので、マウントされたリポジトリを使用しない場合は、このサービスを無効にすることができます。

この処理を行うには、[OSGi サービス](/help/sites-deploying/configuring-osgi.md)である **CQ DAM Asset Synchronization Service** を設定して、**同期期間**（`scheduler.period`）を（最低）1 年（秒数で定義）にします。

### 複数の DAM インスタンス {#multiple-dam-instances}

複数の DAM インスタンスをデプロイすると、パフォーマンスの強化に役立ちます。例えば、次のような場合です。

* オーサー環境用の多数のアセットの定期的なアップロードが原因で負荷が高い場合、別の専用の DAM インスタンスがオーサー環境にサービスを提供します。
* 世界各国（米国、ヨーロッパ、アジア）に複数のチームが存在します。

その他の考慮事項は次のとおりです。

* 作成者の「処理中の作業」と発行の「最終版」を分離する
* オーサーの内部ユーザーとパブリッシュの外部の訪問者／ユーザー（代理人、報道関係者、顧客、受講生など）を分離する。

## 品質保証のベストプラクティス {#best-practices-for-quality-assurance}

パブリッシュ環境にとって、パフォーマンスは最も重要です。したがって、プロジェクトの実装時に、パブリッシュ環境に対して行うパフォーマンステストを慎重に計画し、分析する必要があります。

この節では、特に&#x200B;*パブリッシュ*&#x200B;環境のパフォーマンステストのテストコンセプトを定義する際の問題を標準的な観点から概説します。この情報は、主に QA エンジニア、プロジェクトマネージャーおよびシステム管理者向けの内容となっています。

次に、*パブリッシュ*&#x200B;環境での AEM アプリケーションのパフォーマンステストへの標準化されたアプローチを説明します。このパフォーマンステストには、次の 5 つの段階が含まれます。

* [知識の検証](#verification-of-knowledge)
* [範囲の定義](#scope-definition)
* [テスト方法](#test-methodologies)
* [パフォーマンスの目標の定義](#defining-the-performance-goals)
* [最適化](#optimization)

制御は、すべてを包含する追加のプロセスであり、テストに必要ですが、それに限定されるものではありません。

### 知識の検証 {#verification-of-knowledge}

最初の手順は、テストを開始する前に知っておく必要がある基本情報をドキュメント化することです。

* テスト環境のアーキテクチャ
* テストの必要な内部要素を詳細に示したアプリケーションマップ（単体で使用する場合と組み合わせて使用する場合の両方）

#### アーキテクチャのテスト {#test-architecture}

パフォーマンステストに使用するテスト環境のアーキテクチャを文書化します。

計画した実稼働のパブリッシュ環境、Dispatcher およびロードバランサーを再現する必要があります。

#### アプリケーションマップ {#application-map}

アプリケーション全体のマップを作成できる明確な概要を取得します（オーサー環境でのテストからこの情報を既に入手している可能性があります）。

アプリケーションの内部要素を図で表すことで、テスト要件の概要を示すことができます。色分けしたマップは、レポートのベースとしての役割も果たします。

### 範囲の定義 {#scope-definition}

通常、アプリケーションには様々なユースケースがあります。重要なユースケースもあれば、それほど重要でないものもあります。

パブリッシュでのパフォーマンステストの範囲を絞り込むために、以下を定義することをお勧めします。

* 最も重要な業務上の事例
* 最も不可欠な技術上の事例

ユースケースの数は状況に応じて異なりますが、管理しやすい数（例えば 5～10）に制限する必要があります。

主要なユースケースを選択したら、測定に使用する重要業績評価指標（KPI）とツールをユースケースごとに定義できます。一般的な KPI の例を次に示します。

* エンドツーエンドの応答時間
* サーブレットの応答時間
* 単一のコンポーネントの応答時間
* サービスの応答時間
* スレスレッドプール内のアイドルスレッドの数
* 空き接続数
* CPU や I/O アクセスなどのシステムリソース

### テスト方法 {#test-methodologies}

この概念には、パフォーマンス目標の定義とテストに使用する 4 つのシナリオがあります。

* 単一コンポーネントテスト
* 組み合わせコンポーネントのテスト
* *運用開始*&#x200B;シナリオ
* エラーシナリオ

次の原則に基づきます。

#### コンポーネントのブレークポイント {#component-breakpoints}

* 各コンポーネントには、パフォーマンスに関連する特定のブレークポイント（限界点）があります。つまり、特定のポイントに達するまではコンポーネントのパフォーマンスが良好で、そのポイントを超えるとパフォーマンスが急激に低下します。
* アプリケーションの概要をすべて把握するには、最初にコンポーネントを検証して、それぞれのブレークポイントを確認しておく必要があります。
* ブレークポイントを検出するために、負荷テストを実施できます。このテストでは、ある特定の期間にわたってユーザー数を増やして負荷を上げていきます。この負荷およびコンポーネントの応答を監視することにより、コンポーネントのブレークポイントに達したときの特定のパフォーマンスの動作を確認できます。このポイントは、1 秒あたりの同時トランザクションの数と同時ユーザーの数によって限定できます（コンポーネントがこの KPI の影響を受ける場合）。
* この情報は、改善のためのベンチマークとして機能し、使用される測定の効率を示し、テストシナリオの定義に役立ちます。

#### トランザクション {#transactions}

* トランザクションという用語は、ページ自体と後続のすべての呼び出しを含む、完全な web ページのリクエストを表すために使用されます。つまり、ページリクエスト、AJAX 呼び出し、画像およびその他のオブジェクト&#x200B;**リクエストドリルダウン**&#x200B;などです。
* 各リクエストを完全に分析するには、コールスタックの各要素を表現してから、それぞれの平均処理時間の合計を求めることができます。

### パフォーマンス目標の定義 {#defining-the-performance-goals}

範囲と関連 KPI を定義したら、特定のパフォーマンス目標を設定します。このプロセスでは、テストシナリオとターゲット値の策定が必要になります。

平均条件下とピーク条件下の両方でパフォーマンスをテストします。さらに、運用開始シナリオのテストを実施して、初公開時の web サイトに対する関心の増加に対応できることを確認する必要があります。

既存の web サイトから収集した任意のエクスペリエンスや統計情報も、今後の目標の決定に役立ちます。例えば、ライブ web サイトで最も多いトラフィックです。

#### 単一コンポーネントテスト {#single-component-tests}

極めて重要なコンポーネントは、平均条件下とピーク条件下の両方でテストする必要があります。

どちらの場合も、定義済みの数のユーザーがシステムを使用する際の 1 秒あたりのトランザクションの予想数を定義できます。

| コンポーネント | テストタイプ | いいえ。/ユーザー | トランザクション/秒（予想値） | トランザクション/秒（テスト値） | 説明 |
|---|---|---|---|---|---|
| ホームページのシングルユーザー | 平均 | 1 | 1 |  |  |
|   | ピーク | 1 | 3 |  |  |
| ホームページ 100 人のユーザー | 平均 | 100 | 3 |  |  |
|   | ピーク | 100 | 3 |  |

#### 組み合わせコンポーネントのテスト {#combined-component-tests}

組み合わせてコンポーネントをテストすると、アプリケーションの動作がより詳細に反映されます。再び平均時とピーク時の条件でテストする必要があります。

| シナリオ | コンポーネント | いいえ。/ユーザー | トランザクション/秒（予想値） | トランザクション/秒（テスト値） | 説明 |
|---|---|---|---|---|---|
| 混在：平均時 | ホームページ | 10 | 1 |  |  |
|   | 検索 | 10 | 1 |  |  |
|   | ニュース | 10 | 2 |  |  |
|   | イベント | 10 | 1 |  |  |
|   | アクティベーション | 10 | 3 |  | 作成者の動作のシミュレーション |
| 混在：ピーク時 | ホームページ | 100 | 5 |  |  |
|   | 検索 | 50 | 5 |  |  |
|   | ニュース | 100 | 10 |  |  |
|   | イベント | 100 | 10 |  |  |
|   | アクティベーション | 20 | 20 |  | 作成者の動作のシミュレーション |

#### 運用開始のテスト {#going-live-tests}

Web サイトが公開されてからの最初の数日間は、より高い関心レベルを期待できます。このシナリオは、テストするピーク時の値よりも大きくなります。アドビでは、運用開始のシナリオをテストして、システムがこの状況に対応できることを確認することをお勧めします。

| シナリオ | テストタイプ | いいえ。/ユーザー | トランザクション/秒（予想値） | トランザクション/秒（テスト値） | 説明 |
|---|---|---|---|---|---|
| 運用開始：ピーク時 | ホームページ | 200 | 20 |  |  |
|   | 検索 | 100 | 10 |  |  |
|   | ニュース | 200 | 20 |  |  |
|   | イベント | 200 | 20 |  |  |
|   | アクティベーション | 20 | 20 |  | 作成者の動作のシミュレーション |

#### エラーシナリオテスト {#error-scenario-tests}

エラーシナリオをテストし、システムが正しく適切に対応していることを確認します。エラー自体の処理方法だけでなく、エラーがパフォーマンスに与える影響についても説明します。次に例を示します。

* ユーザーが検索ボックスに検索用語を入力しようとするとどうなるか
* 検索用語が一般的すぎて、返される結果の数が非常に多い場合はどうなるか

このようなテストの策定時には、すべてのシナリオが定期的に発生するわけではない点に注意してください。ただし、テストがシステム全体に及ぼす影響は重要です。

| エラーのシナリオ | エラータイプ | いいえ。/ユーザー | トランザクション/秒（予想値） | トランザクション/秒（テスト値） | 説明 |
|---|---|---|---|---|---|
| 検索コンポーネントのオーバーロード | グローバルワイルドカード（アスタリスク）で検索 | 10 | 1 |  | &ast;&ast;&ast; のみが検索されます。 |
|   | ストップワード | 20 | 2 |  | ストップワードの検索。 |
|   | 空の文字列 | 10 | 1 |  | 空の文字列の検索。 |
|   | 特殊文字 | 10 | 1 |  | 特殊文字の検索。 |

#### 耐久テスト {#endurance-tests}

システムを継続的な期間（数時間または数日）実行した後にのみ発生する問題があります。耐久テストは、必要とされるある一定の期間にわたる、継続的な平均負荷を確認するために使用します。その後、パフォーマンスの低下を分析できます。

| シナリオ | テストタイプ | いいえ。/ユーザー | トランザクション/秒（予想値） | トランザクション/秒（テスト値） | 説明 |
|---|---|---|---|---|---|
| 耐久テスト（72 時間） | ホームページ | 10 | 1 |  |  |
|   | 検索 | 10 | 1 |  |  |
|   | ニュース | 20 | 2 |  |  |
|   | イベント | 10 | 1 |  |  |
|   | アクティベーション | 1 | 3 |  | 作成者の動作のシミュレーション |

### 最適化 {#optimization}

実装の後半の段階では、アプリケーションを最適化して、パフォーマンスの目標を達成または最大化します。

実施した最適化をすべてテストして、次の点を確認してください。

* 機能に影響を及ぼさない
* リリース前に負荷テストを実施して検証済みである

負荷の生成、パフォーマンスの監視および結果の分析に役立つ様々なツールが用意されています。これらのツールの一部を次に示します。

* [JMeter](https://jmeter.apache.org/)
* [Load Runner](https://www.microfocus.com/en-us/portfolio/performance-engineering/overview)
* [Java™ Interactive Profile](https://jiprof.sourceforge.net/)

最適化後、再度テストして影響を確認します。

### レポート {#reporting}

継続的なレポートにより、すべてのユーザーが状況を把握できます。前述のように、色分けでアーキテクチャマップをこの状態に使用できます。

すべてのテストが完了したら、次の情報を報告します。

* 発生した重大なエラー
* 重大ではない問題（詳細な調査は必要）
* テスト中の想定事項
* テストから得られたレコメンデーション

## Dispatcher の使用時のパフォーマンスの最適化 {#optimizing-performance-when-using-the-dispatcher}

[Dispatcher ](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/dispatcher.html?lang=ja) はアドビのキャッシュ／ロードバランシングツールです。Dispatcher を使用する場合は、キャッシュパフォーマンスを確保するために web サイトの最適化を検討してください。

>[!NOTE]
>
>Dispatcher のバージョンは AEM とは無関係ですが、Dispatcher のドキュメントは AEM のドキュメントに組み込まれています。最新バージョンの AEM のドキュメントに組み込まれている Dispatcher のドキュメントを必ず使用してください。
>
>以前のバージョンの AEM のドキュメントに組み込まれている Dispatcher ドキュメントへのリンクをたどった場合は、このページにリダイレクトされている可能性があります。

Dispatcher には、web サイトで活用するとパフォーマンスが最適化される、複数の組み込みのメカニズムが用意されています。この節では、キャッシュのメリットを最大化するように web サイトをデザインする方法について説明します。

>[!NOTE]
>
>まず覚えておいてほしいのは、Dispatcher は標準の web サーバーにキャッシュを格納するという点です。この情報を把握することで、URL を使用して、ページとして保存したり、リクエストしたりできるすべての項目をキャッシュできるようになります。Cookie、セッションデータ、フォームデータなど、その他のものは格納できません。
>
>通常、多くのキャッシュ戦略は適切な URL の選択を含んでおり、この追加データには依存しないことです。
>
>Dispatcher バージョン 4.1.11 では、応答ヘッダーをキャッシュすることもできます。[HTTP 応答ヘッダーのキャッシュ](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=ja#configuring-the-dispatcher-cache-cache)を参照してください。
>

### Dispatcher のキャッシュ率の計算 {#calculating-the-dispatcher-cache-ratio}

キャッシュ率の計算式では、システムが受け取ったリクエスト総数のうちキャッシュによって処理されたリクエストの割合が概算されます。キャッシュ率を計算するには、次の情報が必要です。

* 要求の総数。この情報は、Apache の `access.log` で確認できます。詳しくは、[公式の Apache ドキュメント](https://httpd.apache.org/docs/2.4/logs.html#accesslog)を参照してください。

* パブリッシュインスタンスが提供したリクエスト数。この情報は、インスタンスの `request.log` で確認できます。詳しくは、[request.log の解釈](/help/sites-deploying/monitoring-and-maintaining.md#interpreting-the-request-log)および[ログファイルの検索](/help/sites-deploying/monitoring-and-maintaining.md#finding-the-log-files)を参照してください。

キャッシュ率の計算式は次のとおりです。

* 要求の総数から公開における要求の数を&#x200B;**差し引き**、それを要求の総数で&#x200B;**割ります**。

例えば、リクエスト総数が 129,491 であり、パブリッシュインスタンスによって処理されたリクエスト数が 58,959 である場合、キャッシュ率は **(129,491 - 58,959)/129,491 = 54.5％**&#x200B;です。

パブリッシャーと Dispatcher が 1 対 1 のペアでない場合、正確な測定値を得るには、すべての Dispatcher とパブリッシャーからのリクエストを加算します。詳しくは、[推奨されるデプロイメント](/help/sites-deploying/recommended-deploys.md)も参照してください。

>[!NOTE]
>
>最高のパフォーマンスを得るために、アドビではキャッシュの比率を 90％～95％にすることを推奨しています。

#### 一貫したページエンコーディングの使用 {#using-consistent-page-encoding}

Dispatcher バージョン 4.1.11 では、応答ヘッダーをキャッシュできます。Dispatcher で応答ヘッダーをキャッシュしない場合、ページエンコーディング情報をヘッダーに格納すると、問題が生じる可能性があります。この場合、Dispatcher がキャッシュからページを提供すると、ページで web サーバーのデフォルトのエンコーディングが使用されます。この問題を回避する方法は 2 つあります。

* 1 つのエンコーディングのみを使用する場合は、web サーバーで使用されるエンコーディングが、AEM web サイトのデフォルトのエンコーディングと同じであることを確認します。
* エンコーディングを設定するには、次の例のように、`<META>` タグを HTML `head` セクションに使用します。

```xml
        <META http-equiv="Content-Type" content="text/html; charset=EUC-JP">
```

#### URL パラメーターの使用回避 {#avoid-url-parameters}

可能な限り、キャッシュするページの URL パラメーターは使用しないでください。例えば、ピクチャーギャラリーがある場合、次の URL はキャッシュされません（Dispatcher が [適切に設定](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=ja#configuring-the-dispatcher-cache-cache)されている場合を除く）。

```xml
www.myCompany.com/pictures/gallery.html?event=christmas&amp;page=1
```

ただし、次のように、これらのパラメーターをページ URL に配置できます。

```xml
www.myCompany.com/pictures/gallery.christmas.1.html
```

>[!NOTE]
>
>この URL は、`gallery.html` と同じページおよび同じテンプレートを呼び出します。テンプレートの定義では、ページをレンダリングするスクリプトを指定できます。または、すべてのページに同じスクリプトを使用できます。

#### URL でカスタマイズ {#customize-by-url}

ユーザーがフォントサイズ（またはその他のレイアウトのカスタマイズ）を変更できるようにする場合は、様々なカスタマイズが URL に反映されていることを確認します。

例えば、Cookie はキャッシュされないので、フォントサイズを Cookie（または同様のメカニズム）に格納した場合、キャッシュされたページのフォントサイズは保持されません。その結果、Dispatcher は任意のフォントサイズのドキュメントをランダムに返します。

URL にフォントサイズをセレクターとして含めると、次の問題を回避できます。

```xml
www.myCompany.com/news/main.large.html
```

>[!NOTE]
>
>レイアウトのほとんどの側面で、スタイルシート、クライアントサイドスクリプトまたはその両方を使用することもできます。これらの機能はキャッシュとうまく連携します。
>
>この戦略は印刷版でも役立ちます。次のような URL を使用できます。
>
>`www.myCompany.com/news/main.print.html`
>
>テンプレート定義のスクリプトグロビングを使用して、印刷ページをレンダリングする個別のスクリプトを指定できます。

#### タイトルとして使用されている画像ファイルの無効化 {#invalidating-image-files-used-as-titles}

ページのタイトルや他のテキストを画像としてレンダリングする場合は、ページ上のコンテンツの更新時にファイルが削除されるように、ファイルを保存することをお勧めします。

1. 画像ファイルを、ページと同じフォルダーに配置します。
1. 画像ファイルに次の命名形式を使用します。



   `<page file name>.<image file name>`

例えば、`file myPage.title.gif` にページ のタイトル `myPage.html` を格納できます。ページが更新されると、このファイルは自動的に削除されるので、ページタイトルに対する変更はキャッシュに自動的に反映されます。

>[!NOTE]
>
>画像ファイルは、必ずしも AEM インスタンス上に物理的に存在するわけではありません。画像ファイルを動的に作成するスクリプトを使用できます。次に、Dispatcher がファイルを web サーバーに保存します。

#### ナビゲーションに使用された画像ファイルの無効化 {#invalidating-image-files-used-for-navigation}

ナビゲーションエントリに画像を使用する場合、この方法はタイトルと同じですが、少し複雑です。すべてのナビゲーション画像をターゲットページと共に保存します。通常とアクティブ用に 2 つの画像を使用する場合は、次のスクリプトを使用できます。

* 通常どおりページを表示するスクリプト。
* 「.normal」リクエストを処理し、通常の画像を返すスクリプト。
* 「.active」リクエストを処理し、アクティベートされた画像を返すスクリプト。

コンテンツの更新でこれらの画像とページが確実に削除されるように、ページと同じ名前のハンドルでこれらの画像を作成することが重要です。

変更されていないページの場合、画像はキャッシュに残りますが、ページ自体は自動的に無効化されます。

#### パーソナライズ機能 {#personalization}

パーソナライズ機能は必要な場所に制限することをお勧めします。その理由を次に示します。

* 自由にカスタマイズ可能な開始ページを使用する場合は、ユーザーが要求するたびにそのページを構成する必要があります。
* これに対して、10 個の異なる開始ページを選択できるようにする場合は、各ページをキャッシュして、パフォーマンスを向上させることができます。

>[!TIP]
>Dispatcher キャッシュの設定について詳しくは、[AEM Dispatcher Cache チュートリアル](https://experienceleague.adobe.com/docs/experience-manager-learn/dispatcher-tutorial/overview.html?lang=ja)および[保護されたコンテンツのキャッシュ](https://experienceleague.adobe.com/docs/experience-manager-learn/dispatcher-tutorial/chapter-1.html?lang=ja#dispatcher-tips-and-tricks)の節を参照してください。

（例えば）ユーザーの名前をタイトルバーに入れて各ページをパーソナライズすると、パフォーマンスに影響を与えます。

>[!TIP]
>保護されたコンテンツのキャッシュについて詳しくは、Dispatcher ガイドの[セキュリティ保護されたコンテンツのキャッシュ](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/permissions-cache.html?lang=ja)を参照してください。

1 つのページに制限付きコンテンツと公開コンテンツを混在させる場合、Dispatcher のサーバーサイドインクルードを利用する方法や、ブラウザーの Ajax 経由でクライアントサイドインクルードを利用する方法を検討します。

>[!TIP]
>
>公開コンテンツと制限コンテンツが混在している場合の処理については、[Sling ダイナミックインクルードの設定](https://experienceleague.adobe.com/docs/experience-manager-learn/foundation/development/set-up-sling-dynamic-include.html?lang=ja)を参照してください。

#### スティッキー接続 {#sticky-connections}

[スティッキー接続](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/dispatcher.html?lang=ja#the-benefits-of-load-balancing)を使用すると、1 人のユーザー用のドキュメントがすべて同じサーバーで作成されるようになります。ユーザーがそのフォルダーを離れて後から戻ってきた場合も、この接続は維持されます。Web サイトのスティッキー接続に必要なすべてのドキュメントを保持するには、フォルダーを 1 つ定義します。他のドキュメントを中に含めないようにしてください。このシナリオでは、パーソナライズされたページとセッションデータを使用する場合に、ロードバランシングに影響が生じます。

#### MIME タイプ {#mime-types}

ブラウザーがファイルのタイプを判別する方法は 2 とおりあります。

1. 拡張子（例：`.html`、`.gif` および `.jpg`）。
1. サーバーがファイルと共に送信する MIME タイプ。

ほとんどのファイルでは、MIME タイプがファイル拡張子で暗黙に指定されます。つまり

1. 拡張子（例：`.html`、`.gif` および `.jpg`）。
1. サーバーがファイルと共に送信する MIME タイプ。

ファイル名に拡張子がない場合は、プレーンテキストとして表示されます。

Dispatcher バージョン 4.1.11 では、応答ヘッダーをキャッシュできます。Dispatcher で応答ヘッダーをキャッシュしない場合、MIME タイプは HTTP ヘッダーの一部になります。つまり、AEM アプリケーションから返されるファイルが、認識されたファイル拡張子を持たず、代わりに MIME タイプに依存する場合は、ファイルが正しく表示されない可能性があります。

ファイルが適切にキャッシュされるようにするには、次のガイドラインに従います。

* ファイルの拡張子が常に適切であることを確認します。
* `download.jsp?file=2214` のような URL を持つ汎用のファイル提供スクリプトは避けます。ファイル仕様を含んだ URL を使用するには、スクリプトを書き換えます。前の例では、この書き換えは `download.2214.pdf` となります。
